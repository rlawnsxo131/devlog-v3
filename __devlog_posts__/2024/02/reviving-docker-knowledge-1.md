---
title: 도커 기억살리기 1 - 개념편
description: 근 2년만에 쓰는 글이 도커일 줄이야. 쟁여놓은 책도 다시좀 읽어야 것다
tags:
  - Docker
thumbnail: /images/post/thumbnail/john_home_cherry_blossom_2.jpeg
date: 2024-02-02
slug: reviving-docker-knowledge-1
---

# Table Of Contents

# 글을 시작하며

어쩌다 보니 회사에서 SSR 에 관한 작업을 많이 하게 되었다. 현재 근무중인 직장은 k8s 기반으로 거의 모든 서버 리소스가 돌아가고, 컨테이너를 다루기위한 기술로 도커를 사용한다. 헌데 한참 devops 랑 backend 를 실무에서 주로 다루던 시절엔 빠릿빠릿 떠오르던 내용들이 가물가물 하여 이참에 기억을 되살릴겸 정리나 하자 싶어 글을 적는다.

글을 적으려다 보니 도커는 참 대단하단 생각이 든다. [k8s 측이 런타임으로 서의 도커지원을 중단한다는 소식](https://kubernetes.io/ko/blog/2020/12/02/dont-panic-kubernetes-and-docker/)을 듣곤, 아 귀찮은데 podman 같은거 슬슬 봐야하나? 했던 때가 있었다(이땐 실무에서 허구언날 이런 작업만 하던지라 더 쫄렸다). 하지만 주변을 보면 아직도 도커는 컨테이너 관련 솔루션으로서 여전히 건재한것 같은 느낌이다([containerd](https://containerd.io/) 가 있으니 뭐). 사실상 거의 표준이라 해도 과언이 아닌듯 하달까.

# Docker 란

뭐 다들 알겠지만 도커는 `리눅스 컨테이너`에 여러 기능을 추가하여, 어플리케이션을 컨테이너로서 좀더 편하게 사용하게 만들어진 오픈소스 프로젝트이다. 뭐 이전부터 이것저것 가격정책은 있었지만, 일단 오픈소스란 말이지. 근데 이녀석이 왜 이리도 핫해졌을까? 뭐가 다를까? 하지만 다른점을 다루기 전에 이전에 컨테이너란 근본적으로 무엇을 뜻하는가를 좀 알아보자.

## 컨테이너(Container)

일단 컨테이너란 무엇인가를 좀 정리하고 싶다. 내가 생각하는 컨테이너의 정의를 한마디로 표현하자면, `독립된 공간에서 프로세스가 격리된채 동작하게 해주는 기술` 이다. 이게 무슨말이냐?

우리가 작성하는 소프트웨어는 결국 os 와 라이브러리에 의존성을 지니고 있다. 우리가 브라우저에서 어떤 라이브러리를 이용해 HTTP 요청을 작성하더라도, 이것은 결국엔 os 의 socket 을 이용해야 하는것처럼 말이다. 이런 의존성을 가진채 우리가 성격이 전혀 다른 어플리케이션 여러개를 하나의 os 위에 띄워야 한다고 생각해보자. 이때, 작동중인 어플리케이션 간의 동작이 서로 간섭하지 않고 안전하게 동작하려면 어떤 요소가 필요할까? 각각의 프로그램이 의존하는 라이브러리나 버전이 전부 달라야 한다면 말이다.

nodejs 로 작성된 어플리케이션 여러개를 하나의 server 에서 실행해야 한다고 가정해보자. 이때 nodejs 어플리케이션이 실행되어야 하는 host 환경이 모두 다르며, 의존하는 nodejs 의 버전이 모두 다르다고 가정해보자. 도대체 어떤 일들이 필요할까? 그냥 생각만 해도 머리가 아프다.

컨테이너라는 개념은 위와같은 문제들을 해결한다. 컨테이너를 실행한다는 것은, `독립된 공간` 에서 특정 프로그램이 동작하기 위한 모든것이 `격리된채` 실행된다는 의미이다. 사실 **모든 컨테이너는 실제로 실행중인 프로세스** 일 뿐이다. 다만 `격리된채` 실행된다는 것을 잊지 않아야 겠다.

아울러 꼭 기억하면 좋겠는게 근본적으로 이 컨테이너는 `리눅스`의 기술이다. 도커가 컨테이너를 실행할때 백그라운드에서 linux 가상 머신을 같이 올려준다. 예전에는 LXC 기반으로 동작했다고 하는데, 현재는(0.9 이후) 여러 환경에서의 실행을 위해 LXC 가 아닌 [libcontainer](https://www.docker.com/blog/docker-0-9-introducing-execution-drivers-and-libcontainer/) 를 기반으로 동작한다. LXC 를 사용할수 있긴 한걸로 알고 있는데, 이렇게 사용하면 일부 명령어도 안먹고 불편한점이 상당히 있는것으로 알고 있다(직접 해본적은 없어서 잘 모르겠다).

또한 특정 시스템콜을 지원하지 않으면 암만 도커를 써도 시스템콜을 호출할 수 없다. 다만, 일반적으로 이용하는 시스템콜은 앵간하면 지원하기 때문에(잘 변하지도 않는다) 문제가 될만한 상황은 크게 없을것으로 보인다.

즉 도커는 시스템콜을 공유하는 만큼 host OS 에 종속적이며, 머신에 영향을 받지 않는것은 아니다. m1 맥이 처음 나왔을때 이걸 도커측에서 지원해주길 기다리며 펑펑 터지는걸 꼼수로 처리하던 기억이 있는 사람들이라면 알것이다. 머신 아키텍처에 영향을 받는다.

```
도커는 컨테이너가 자체가 아니다.
컨테이너를 관리하기 위한 많은 기능을 지닌채, 컨테이너 관리에 필요한 기능들을
편리하게 이용할 수 있게 만들어진 툴이다.
```

## 가상화

도커란 녀석을 구글링 하다보면 항상 만나는게 **system call 혹은 커널을 공유한다** 라는 문구이다. 이부분은 워낙 자료가 많긴한데 그냥 정리해본다. 우선 이 커널을 공유한다는게 얼마나 큰 의미인지 알기 위해선 도커 이전의 가상화 기술을 살펴보아야 한다.

### 가상화 기술

기존의 가상화 기술은 하이퍼바이저를 이용해 여러개의 운영체제를 하나의 호스트에서 생성해 사용하는 방식이었다. 이러한 여러 개의 운영체제는 가상 머신이라는 단위로 구분되고, 각 가상머신에는 Ubuntu, CentOS 등의 운영체제가 설치되어 사용된다. 당연히도 OS 자체를 가상화 하다보니 무거울수 밖에 없다. 가상 머신은 게스트 운영체제를 사용하기 위한 라이브러리, 커널등을 전부 포함하기 때문에 그럴수밖에.

아울러 각종 시스템 자원을 가상화하고 독립된 공간을 생성하는 작업은 하이퍼바이저를 무조건 거치게 되는데, 이때 일반 호스트에 비하여 성능 손실이 발생한다.

- 하이퍼바이저: 호스트 컴퓨터에서 다수의 운영 체제를 동시에 실행하기 위한 논리적 플랫폼(virtual machine monitor 또는 virtual machine manager, 줄여서 VMM).
- Guest OS: 하이퍼바이저를 통해 생성되고 관리되는 운영체제. 즉 host OS 에 올라가는 가상화된 녀석.

이를 해결하기 위해 CPU의 가상화 기술([HVM](https://en.wikipedia.org/wiki/Hardware-assisted_virtualization))을 이용한 [KVM](https://linux-kvm.org/page/Main_Page)(Kernel-based Virtual Machine)과 [반가상화](https://en.wikipedia.org/wiki/Paravirtualization)(Paravirtualization)방식의 Xen이 등장한다. 이러한 방식은 게스트 OS가 필요하긴 하지만 전체OS를 가상화하는 방식이 아니였기 때문에 호스트형 가상화 방식에 비해 성능이 향상 되었다.

- 전가상화(Hardware Virtual Machine): 어려운말 재끼고 그냥 하드웨어를 완전히 가상화 하는 기술. Guest OS 의 수정이 필요 없다. 그대신 무겁다.
- 반가상화(Para-Virtualization): 하드웨어를 완전히 가상화 하지 않고, 하이퍼콜이라는 인터페이스를 통해 하이퍼바이저에게 요청을 날리는 형식. Guest OS 를 수정하여 특정 명령을 날릴때 하이퍼콜을 호출한다. 비교적 가볍긴 하지만 Guest OS 를 수정해야 한다. 말인즉슨 오픈소스 아니면 곤란하지 않겠는가.

![virtual_machines_containers](/images/post/2024/02/virtual_machines_containers.png)
[이미지 출처](https://www.weave.works/blog/a-practical-guide-to-choosing-between-docker-containers-and-vms)

하지만 전가상화든 반가상화든 추가적인 OS를 설치하여 가상화하는 방법은 어쨋든 성능문제가 있었고 이를 개선하기 위해 프로세스를 격리 하는 방식이 등장한다.

리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작한다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 손실이 미미하다.

한가지 추가로 언급하고 싶은점은 **os 가상화가 안좋아 보이지만 그것도 아니다.** 격리수준은 더 높아 보안적인 측면에선 뛰어난 것으로 알고있다. 다만, 이 os 레벨의 가상화가 가지는 이점은 현대의 어플리케이션이 돌아가는 환경에 잘 맞는부분이 많기에 "시기에 잘 맞는 기술이다" 라는 말이 조금더 맞는듯 하다.

### 성능

일단 리눅스 컨테이너를 구현하려면 `리눅스 시스템 콜`인 `chroot`나 `namespace`, `cgroup`, `unionmount` 등의 기능을 활용해야 한다. 이때 도커는 `libcontainer` 로 인해 리눅스 커널 기능인 cgroups, namespaces 등을 직접적으로 활용할 수 있다. 아울러 이런식으로 리눅스 컨테이너 기술을 활용한 프로세스 단위의 격리환경을 만들기 때문에 성능의 손실이 거의 없다.

직전에 전가상화/반가상화 와 하이퍼바이저를 언급하며 설명했듯, 일단 이 하이퍼바이저를 통해 무언가를 실행한다면 내 컨테이너가 실행되는 커널의 기능을 직접적으로 사용하지 못한다는것을 의미한다(뭐 system call 을 호출하는것도 따지고 보면 완벽하게 직접이라고 하는게 맞나 싶기도 하다). 중간에 어떠한 특정 단계가 있으니 오버헤드가 있는것은 당연하다. 아울러 가상화나 반가상화로 만든 환경은 무겁기 때문에, 상대적으로 배포시간이 길어질수 밖에 없다.

즉 이 도커라는 녀석은

1. 컨테이너에 필요한 커널은 호스트의 커널을 공유하여 사용하고
2. 컨테이너 안에는 어플리케이션을 구동하는데 필요한 라이브러리 및 실행 파일만 존재하기 때문에 이미지의 크기가 작다.
3. 이미지의 크기가 작으니 가상 머신에 비해 이미지를 만드는 속도가 빠르며, 이미지 저장소에 push 를 한다는 등의 행위에 속도가 빠를수 밖에 없다. 즉 배포시간이 비교적 빠르며 작은 이미지 덕에 부담이 적다.
4. 리눅스의 가상화 기술을 기반으로 작동하는 만큼 단순히 프로세스를 격리시키기 때문에, 가상화된 공간을 사용할때의 성능 손실이 훨씬 적을수 밖에 없다. 즉 빠르다.

## 이미지(Image)

# Ref

- [docker vs containerd](https://blog.purestorage.com/purely-informational/containerd-vs-docker-whats-the-difference/)
